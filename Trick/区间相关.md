# 区间相关
## 切分数组
1. 如果一个题目可以用分治解决，那么这个题目的带修改版本可以用线段树解决。（来自灵神）
2. 切分区间的时候，遇到边界问题，可以考虑 1.选 2.不选 3.可选可不选

## 子数组相关
1. 题目要求找一个满足条件的子数组时，暴力解法是枚举左右端点`[left,right]`，复杂度$O(n^2)$。优化的时候考虑，从左往右（从右往左）枚举某个点的时候，以当前的点为右端点（左端点）的情况，并且当前的点可以为接下去要枚举的点做出什么贡献。
2. 考虑以`i`为右端点的子数组的动态规划，枚举`i`。复杂度优化到`O(n)`
3. 暴力加优化，在暴力枚举的时候，第二层循环可以不用遍历`n`个，根据题目的要求，有时候只需要遍历$\sqrt n$个。复杂度优化到$O(n\sqrt n)$
4. 要善于利用题目中的隐藏信息，如固定子数组的一个端点（如右端点），当另一个端点（如左端点）往一个方向移动的时候（左或右），该子数组中某种数量（根据题意分析）是递增或者递减的，这个时候往往可以利用二分或者滑动窗口的算法降低复杂度
5. Tips: 一般考察$O(n\log n)$的算法数据范围都是$1e5$或者$2e5$，当发现数据范围比较奇怪的时候（如$4e4$）就要考虑$O(n\sqrt n)$的做法了

## 子序列相关
1. 上升子序列（IS）问题

在求解最长「上升子序列（IS）」问题时，一般有两种优化方法：
- 维护固定长度的`IS`的末尾元素的最小值 + 二分优化。（定义`d[i]`为长度为`i`的`IS`末尾最小值）
- 基于值域的线段树、平衡树等数据结构优化。（定义`dp[i][j]`，表示`nums`的前`i`个元素中，以元素`j`（注意不是`nums[j]`）结尾的最长IS）。如果`nums[i]!=j`，则`dp[i][j]=dp[i-1][j]`，否则`dp[i][j]=max(dp[i-1][k]+1),(k<j)`。
假设用线段树维护，可以把dp的第一维去掉，因为总是从`i-1`推到`i`。

这两种做法都可以用 `O(nlog⁡n)` 的时间解决`[最长递增子序列]`问题。(转载自灵神)当题目中出现其他额外附加条件的时候，考虑这两个优化方式。

## 区间
考虑`dp[i][j]`可以表示闭区间`[i,j]`的答案或开区间`(i,j)`的答案,或者左开右闭，右开左闭区间的答案

## 数位dp
数位dp的一般套路为记忆化搜索，`dfs(int i, int state,...)`，一般一定会有的两个参数为，1. 当前马上要在第i位操作，2. 当前的状态state(一般是状态压缩后的一个整数)，它的值决定了当前可以做什么操作


